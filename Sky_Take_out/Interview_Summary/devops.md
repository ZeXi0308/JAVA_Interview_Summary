## 为什么 DevOps 能让反馈路径变短？

- **自动化工具和流程**

    DevOps 推崇 CI/CD（持续集成/持续交付），把构建、测试、部署都自动化。
    代码一提交，系统会自动跑测试、自动构建、自动部署，几分钟内就能发现问题，不需要人来回通知。

- **开发、测试、运维协同工作**

    DevOps 打破了“开发-测试-运维”之间的墙，让大家更紧密合作，信息流动更快。
    以前开发写完给测试，测试再给运维，中间等待沟通很久。DevOps 强调大家一起工作，减少等待。

- **持续监控和实时报警**

    DevOps 会集成各种监控系统，发现线上异常第一时间通知相关人员，不需要等到客户投诉。

    监控+自动报警，反馈即时。

- **小步快跑，频繁交付**

    传统模式下，一次上线周期可能是几周甚至几个月，问题发现和修复都很慢。
    DevOps 提倡快速迭代，一天多次上线，出现问题能立刻修复并上线。

---

### CI/CD是什么

CI/CD 是两个概念的缩写，它们共同构成了一套通过自动化来频繁、可靠地向用户交付应用的实践方法。

- **CI (Continuous Integration / 持续集成)**

- **CD (Continuous Delivery / 持续交付 & Continuous Deployment / 持续部署)**

您可以把它想象成一个软件开发的“自动化生产流水线”，从工程师写下第一行代码开始，一直到最终用户能用上新功能为止。

#### **第一部分：CI (持续集成) - 质量的守护者**

核心思想： 开发人员频繁地（每天多次）将自己的代码更改合并到主代码库中。

**为什么这么做？**

在过去，开发团队可能长达数周甚至数月才合并一次代码，这会导致巨大的冲突和难以修复的 Bug，被称为“集成地狱”。持续集成通过“少量多次”的方式完美解决了这个问题。

自动化流程：
当任何一位开发者提交代码后，CI 流水线会自动被触发，执行以下步骤：

1. 获取代码 (Fetch)： 从代码仓库（如 GitHub）拉取最新的代码。
    - 这一步一般会执行像 git clone 或者 git fetch 之类的命令。fecth之后保存在本地的远程分支里面，远程分支就是你本地保存的、远程仓库对应分支的最新快照，是用来和远程仓库同步和比对用的。它不会影响你本地正在开发的分支。

2. 构建 (Build)： 将源代码编译成可执行的软件。对于 Java 项目，就是运行 mvn package 生成一个 .jar 文件。

3. 测试 (Test)： 运行各种自动化测试（如单元测试、集成测试），确保新的代码没有破坏原有功能。

4. 反馈 (Feedback)：
   - 如果失败： 任何一个步骤失败，流水线会立刻停止，并立即通知相关开发者。这实现了“快速失败”，让 Bug 在萌芽阶段就被发现和修复。
   - 如果成功： 流水线会生成一个通过了所有验证的“产物”(Artifact)，比如一个可运行的 JAR 包，或者一个打包好的 Docker 镜像。

**CI 的目标： 确保主代码库在任何时候都是健康的、可构建的、经过测试的。**

#### **第二部分：CD (持续交付/部署) - 自动化的延伸**
CD 是 CI 的自然延伸。当 CI 成功地构建并验证了一个“产物”后，CD 负责将这个产物送到用户手中。CD 有两个层次：

**1. 持续交付 (Continuous Delivery)**

流程： CI 成功后，自动将应用程序部署到类似生产的环境（如“测试环境”或“预发布环境”）。

关键点： 部署到最终的生产环境这一步，需要人为地手动点击一下按钮来确认。

目的： 确保软件在任何时候都处于可发布状态。最终的发布时机可能需要根据市场活动、运营计划等商业决策来定，但从技术上讲，一键即可发布。

**2. 持续部署 (Continuous Deployment)**

流程： 这是 CD 的最高境界。一旦代码通过了所有自动化测试阶段，它将自动地、无需任何人工干预地被直接部署到生产环境，交付给最终用户。

关键点： 完全自动化，无人干预。

目的： 实现最快速的价值交付。这要求团队对自动化测试有极高的信心。像亚马逊、Netflix 这样的公司每天都进行上千次这样的自动部署。

#### 一个完整的 CI/CD 流程示例
我们以一个 Java 项目部署到 KubeSphere 为例：

1. 编码 (Code): 开发者在自己电脑上完成一个新功能，并将代码推送到 GitHub。

2. 持续集成 (CI):

    GitHub 的推送操作自动触发了 KubeSphere 内置的 Jenkins 流水线。

3. 流水线开始执行：

    - 拉取最新代码。

    - 运行 mvn test 执行单元测试。

    - 运行 mvn package 将项目打包成 app.jar。

    - 根据 Dockerfile 构建一个新的 Docker 镜像。

    - 将新镜像推送到镜像仓库（如 Harbor）。

    - CI 阶段成功！ 我们得到了一个经过验证的、包含新功能的 Docker 镜像。

4. 持续交付 (CD):

   - 流水线继续执行，自动将这个新镜像部署到 KubeSphere 的“测试集群”中。

   - 在测试集群中运行自动化端到端测试。

   - 流水线暂停，等待人工审批。

5. 人工验证与发布:

   - 测试工程师（QA）在测试环境中手动验证新功能，确保一切正常。

   - 产品经理确认当前是发布的最佳时机。

   - 他们在流水线界面上点击“批准发布”按钮。

6. 生产部署:

   - 流水线接收到批准指令后，继续执行最后一步。

   - 将同一个 Docker 镜像部署到 KubeSphere 的“生产集群”中。

   - 发布完成！ 最终用户现在可以使用到新功能了。

---