## 远程过程调用（Remote Procedure Call, RPC）

是一种计算机通信协议。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。其核心思想是让调用远程服务像调用本地方法一样简单。

---
### 背景：一个服务如何调用另一个部署在不同机器上的服务的功能呢？

最直接的方式是使用 HTTP/JSON。比如订单服务想获取用户信息，可以向用户服务发起一个 HTTP GET 请求。这种方式当然可行，但存在一些问题：

- 性能开销： HTTP 协议是文本协议，包含了大量的请求头信息，相对冗余；JSON 的序列化和反序列化开销也比较大。

- 服务发现： 订单服务如何知道用户服务的 IP 地址和端口？

- 面向过程： 开发者需要手动去拼接 URL、构造 HTTP 请求、解析 JSON 响应，思维模式停留在“发送网络请求”，而不是“调用一个功能”。

为了解决这些痛点，RPC 框架应运而生。它的目标就是让程序员忘记底层的网络细节，像调用本地接口一样调用远程服务，从而极大地提高了开发效率。

### RPC 的核心组成部分：

- **客户端 (Client): 服务调用方。**

    客户端存根 (Client Stub): 存放在客户端的一段代码，负责接收客户端的本地调用请求，并将其打包（**序列化**）、通过网络发送给服务端。它表现得像一个本地方法的代理。

- **服务端 (Server): 服务提供方。**

    服务端存根 (Server Stub): 存放在服务端的一段代码，负责接收并解析（反序列化）从网络传来的请求，然后调用真正的业务逻辑方法，最后将执行结果打包（序列化）返回给客户端。

- 网络协议 (Network Protocol): 负责在客户端和服务端之间传输数据。这可以是 TCP、UDP，或者更上层的 HTTP 等。

```mermaid

sequenceDiagram
    participant Client as 客户端
    participant ClientStub as 客户端存根
    participant RPCNetwork as RPC网络层
    participant ServerStub as 服务端存根
    participant Server as 服务端

    rect rgb(239, 245, 255)
        Client->>+ClientStub: 1. 调用本地方法 (e.g., getUserById(123))
        ClientStub->>ClientStub: 2. 将方法名和参数<br/>序列化 (打包)
        ClientStub->>+RPCNetwork: 3. 通过网络发送请求
    end

    RPCNetwork->>+ServerStub: 4. 接收到网络请求
    ServerStub->>ServerStub: 5. 反序列化 (解包)<br/>得到方法名和参数

    rect rgb(255, 250, 240)
        ServerStub->>+Server: 6. 根据方法名和参数<br/>调用真实的服务逻辑
        Server-->>-ServerStub: 7. 返回执行结果 (e.g., User对象)
    end

    rect rgb(239, 245, 255)
        ServerStub->>ServerStub: 8. 将结果序列化 (打包)
        ServerStub->>-RPCNetwork: 9. 通过网络发送响应
    end

    RPCNetwork-->>-ClientStub: 10. 接收到网络响应
    ClientStub->>ClientStub: 11. 反序列化 (解包)<br/>得到最终结果
    ClientStub-->>-Client: 12. 将结果返回给调用处
```


**网络传输：** 客户端存根通过底层的网络协议（如TCP）将打包好的数据发送到服务端。



---

### 什么是粘包问题

**粘包问题简述**

粘包问题（Packet Stickiness）是指在基于TCP协议进行网络通信时，发送方连续发送多份数据包，而接收方在一次读取操作中，可能会把多个数据包的数据合在一起读取，导致数据边界丢失，接收方无法区分每个数据包的起止。这种现象称为“粘包”。

**为什么会出现粘包？**

- TCP是面向字节流的协议，它只保证数据按顺序到达，不保证每次发送的数据就会被一次性接收。

- 发送方多次send，操作系统或网络栈为了效率，可能将多次发送的数据合并一起发出。

- 接收方调用recv或read时，读取到的数据可能是一个完整包，也可能是多个包拼在一起，甚至只有一个包的一部分。

所以，纯裸 TCP 是不能直接拿来用的，你需要在这个基础上加入一些 自定义的规则 ，用于区分 消息边界 。

---

### HTTP和RPC

**RPC（Remote Procedure Call）本身并不是一个具体的协议，而是一种 调用方式 。**

1. **HTTP和RPC的区别**：

- 首先要向某个服务器发起请求，你得先建立连接，而建立连接的前提是，你得知道 IP 地址和端口 。这个找到服务对应的 IP 端口的过程，其实就是 服务发现。

- 在 HTTP 中，你知道服务的域名，就可以通过 DNS 服务 去解析得到它背后的 IP 地址，默认 80 端口。

- 而 RPC 的话，就有些区别，一般会有专门的中间服务去保存服务名和 IP 信息，比如 Consul、Etcd、Nacos、ZooKeeper，甚至是 Redis。想要访问某个服务，就去这些中间服务去获得 IP 和端口信息。由于 DNS 也是服务发现的一种，所以也有基于 DNS 去做服务发现的组件，比如 CoreDNS。


2. **底层连接形式**：
- 以主流的 HTTP1.1 协议为例，其默认在建立底层 TCP 连接之后会一直保持这个连接（keep alive），之后的请求和响应都会复用这条连接。

- 而 RPC 协议，也跟 HTTP 类似，也是通过建立 TCP 长链接进行数据交互，但不同的地方在于，RPC 协议一般还会再建个 连接池，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，用完放回去，下次再复用，可以说非常环保。

    **池一般针对“高性能下资源的高效复用”。**

3. **传输的信息：**

    HTTP协议传输的内容以header和body为主：
    ![alt text](image-5.png)